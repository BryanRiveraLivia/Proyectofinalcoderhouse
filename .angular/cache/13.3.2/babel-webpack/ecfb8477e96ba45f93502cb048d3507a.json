{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\"; // array in local storage for registered courses\n\nconst coursesKey = 'ProyFinalCoderHouseCourses';\nconst coursesJSON = localStorage.getItem(coursesKey);\nlet courses = coursesJSON ? JSON.parse(coursesJSON) : [{\n  id: 1,\n  curso: 'Angular',\n  descripcion: 'Aprende a desarrollador formularios dinámicos con Angular',\n  tutor: 'Neill Rivera'\n}];\nexport let FakeBackendInterceptor3 = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor3 {\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      return handleRoute();\n\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith('/courses') && method === 'GET':\n            return getCourses();\n\n          case url.match(/\\/courses\\/\\d+$/) && method === 'GET':\n            return getCourseById();\n\n          case url.endsWith('/courses') && method === 'POST':\n            return createCourse();\n\n          case url.match(/\\/courses\\/\\d+$/) && method === 'PUT':\n            return updateCourse();\n\n          case url.match(/\\/courses\\/\\d+$/) && method === 'DELETE':\n            return deleteCourse();\n\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      } // route functions\n\n\n      function getCourses() {\n        return ok(courses.map(x => basicDetails(x)));\n      }\n\n      function getCourseById() {\n        const course = courses.find(x => x.id === idFromUrl());\n        return ok(basicDetails(course));\n      }\n\n      function createCourse() {\n        const course = body;\n\n        if (courses.find(x => x.clased === course.clase)) {\n          return error(`Course with the curso ${course.clase} already exists`);\n        } // assign course id and a few other properties then save\n\n\n        course.id = newCourseId();\n        courses.push(course);\n        localStorage.setItem(coursesKey, JSON.stringify(courses));\n        return ok();\n      }\n\n      function updateCourse() {\n        let params = body;\n        let course = courses.find(x => x.id === idFromUrl());\n\n        if (params.curso !== course.curso && courses.find(x => x.curso === params.curso)) {\n          return error(`Course with the curso ${params.curso} already exists`);\n        } // update and save course\n\n\n        Object.assign(course, params);\n        localStorage.setItem(coursesKey, JSON.stringify(courses));\n        return ok();\n      }\n\n      function deleteCourse() {\n        courses = courses.filter(x => x.id !== idFromUrl());\n        localStorage.setItem(coursesKey, JSON.stringify(courses));\n        return ok();\n      } // helper functions\n\n\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        })).pipe(delay(500)); // delay observable to simulate server api call\n      }\n\n      function error(message) {\n        return throwError({\n          error: {\n            message\n          }\n        }).pipe(materialize(), delay(500), dematerialize()); // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648);\n      }\n\n      function basicDetails(course) {\n        const {\n          id,\n          curso,\n          descripcion,\n          tutor\n        } = course;\n        return {\n          id,\n          curso,\n          descripcion,\n          tutor\n        };\n      }\n\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n\n      function newCourseId() {\n        return courses.length ? Math.max(...courses.map(x => x.id)) + 1 : 1;\n      }\n    }\n\n  }\n\n  FakeBackendInterceptor3.ɵfac = function FakeBackendInterceptor3_Factory(t) {\n    return new (t || FakeBackendInterceptor3)();\n  };\n\n  FakeBackendInterceptor3.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor3,\n    factory: FakeBackendInterceptor3.ɵfac\n  });\n  return FakeBackendInterceptor3;\n})();\nexport const fakeBackendProvider3 = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor3,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module"}